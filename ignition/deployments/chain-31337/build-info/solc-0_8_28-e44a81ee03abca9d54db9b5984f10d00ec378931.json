{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e44a81ee03abca9d54db9b5984f10d00ec378931",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Eleicao.sol": "project/contracts/Eleicao.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Counters.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
      },
      "project/contracts/Eleicao.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./Urna.sol\";\n\ncontract Eleicao is Urna {\n    event StateChanged(ElectionState previous, ElectionState next);\n    event Voted(address indexed voter, uint indexed candidateId);\n\n    modifier duringVoting() {\n        require(\n            currentElectionState == ElectionState.Voting,\n            \"Votacao inativa\"\n        );\n        require(\n            block.timestamp >= votingStartTime &&\n                block.timestamp < votingEndTime,\n            \"Fora do periodo de votacao\"\n        );\n        _;\n    }\n\n    constructor() {\n        // Inicia sem eleicao em andamento\n        currentElectionState = ElectionState.NotStarted;\n        // owner = msg.sender vem de Ownable (já definido em Urna)\n    }\n\n    // --- ADMIN: fluxo de estados ---\n    function openRegistering()\n        external\n        onlyOwner\n        whenState(ElectionState.NotStarted)\n    {\n        _setState(ElectionState.Registering);\n    }\n\n    function closeRegistering()\n        external\n        onlyOwner\n        whenState(ElectionState.Registering)\n    {\n        // Fecha registro e volta para NotStarted para permitir definir periodo\n        _setState(ElectionState.NotStarted);\n    }\n\n    function openVoting()\n        external\n        onlyOwner\n        whenState(ElectionState.NotStarted)\n    {\n        require(\n            votingStartTime != 0 && votingEndTime != 0,\n            \"Periodo nao definido\"\n        );\n        require(block.timestamp >= votingStartTime, \"Ainda nao comecou\");\n        require(block.timestamp < votingEndTime, \"Periodo expirado\");\n\n        _setState(ElectionState.Voting);\n    }\n\n    function closeVoting() external onlyOwner whenState(ElectionState.Voting) {\n        require(block.timestamp >= votingEndTime, \"Aguarde o fim\");\n        _setState(ElectionState.Ended);\n    }\n\n    // --- VOTO ---\n    function vote(\n        address _voterAddress, // <--- 1. Recebe o endereço do eleitor\n        uint _candidateId\n    ) external duringVoting onlyOwner {\n        // <--- 2. Protegida por onlyOwner\n\n        Voter storage v = voters[_voterAddress]; // <--- 3. Usa o endereço do eleitor\n        require(v.isRegistered, \"Eleitor nao registrado\");\n        require(!v.hasVoted, \"Eleitor ja votou\");\n        require(candidates[_candidateId].id != 0, \"Candidato invalido\");\n\n        v.hasVoted = true;\n        candidates[_candidateId].voteCount += 1;\n\n        emit Voted(_voterAddress, _candidateId); // <--- 4. Emite o endereço do eleitor\n    }\n\n    // --- Utils ---\n    function _setState(ElectionState next) internal {\n        ElectionState prev = currentElectionState;\n        currentElectionState = next;\n        emit StateChanged(prev, next);\n    }\n\n    // Ganhador simples (garante ao menos 1 candidato)\n    function winner()\n        external\n        view\n        whenState(ElectionState.Ended)\n        returns (uint id, string memory name, uint votes)\n    {\n        require(candidateIds.length > 0, \"Sem candidatos\");\n        uint bestVotes;\n        uint bestId;\n        for (uint i = 0; i < candidateIds.length; i++) {\n            uint cid = candidateIds[i];\n            uint vc = candidates[cid].voteCount;\n            if (vc > bestVotes) {\n                bestVotes = vc;\n                bestId = cid;\n            }\n        }\n        Candidate storage c = candidates[bestId];\n        return (c.id, c.name, c.voteCount);\n    }\n\n    function getTotalCandidates() public view returns (uint) {\n        require(\n            currentElectionState == ElectionState.Ended,\n            \"Eleicao nao acabou\"\n        );\n\n        return candidateIds.length;\n    }\n\n    function getVotesCount(uint _candidateId) public view returns (uint) {\n        require(\n            currentElectionState == ElectionState.Ended,\n            \"Eleicao nao acabou\"\n        );\n        require(candidates[_candidateId].id != 0, \"Candidato invalido\");\n\n        return candidates[_candidateId].voteCount;\n    }\n}\n"
      },
      "project/contracts/Urna.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nabstract contract Urna is Ownable {\n    // OZ v5: é obrigatório passar o owner ao Ownable\n    constructor() {}\n\n    enum ElectionState {\n        NotStarted,\n        Registering,\n        Voting,\n        Ended\n    }\n    ElectionState public currentElectionState;\n\n    struct Candidate {\n        uint id;\n        string name;\n        uint voteCount;\n    }\n\n    struct Voter {\n        address walletAddress;\n        bool isRegistered;\n        bool hasVoted;\n    }\n\n    using Counters for Counters.Counter;\n    Counters.Counter private _nextCandidateId;\n\n    mapping(uint => Candidate) public candidates;\n    uint[] public candidateIds;\n\n    mapping(address => Voter) public voters;\n\n    uint public votingStartTime;\n    uint public votingEndTime;\n\n    event VoterRegistered(address indexed _voterAddress);\n    event CandidateAdded(uint indexed _candidateId, string _name);\n    event VotingPeriodSet(uint _startTime, uint _endTime);\n\n    // Helper de estado\n    modifier whenState(ElectionState s) {\n        require(currentElectionState == s, \"Estado invalido\");\n        _;\n    }\n\n    // ADMIN: registro de votantes durante Registering\n    function registerVoter(\n        address _voterAddress\n    ) public onlyOwner whenState(ElectionState.Registering) {\n        require(_voterAddress != address(0), \"Endereco invalido do votante\");\n        require(\n            !voters[_voterAddress].isRegistered,\n            \"Votante ja foi registrado\"\n        );\n\n        voters[_voterAddress] = Voter({\n            walletAddress: _voterAddress,\n            isRegistered: true,\n            hasVoted: false\n        });\n\n        emit VoterRegistered(_voterAddress);\n    }\n\n    // ADMIN: adiciona candidatos durante Registering\n    function addCandidate(\n        string memory _name\n    ) public onlyOwner whenState(ElectionState.Registering) {\n        require(bytes(_name).length > 0, \"Nome do candidato vazio\");\n\n        _nextCandidateId.increment();\n        uint newId = _nextCandidateId.current();\n        candidates[newId] = Candidate(newId, _name, 0);\n        candidateIds.push(newId);\n\n        emit CandidateAdded(newId, _name);\n    }\n\n    // ADMIN: definir periodo antes de abrir a votacao\n    function setVotingPeriod(\n        uint _startTime,\n        uint _endTime\n    ) public onlyOwner whenState(ElectionState.NotStarted) {\n        require(_startTime >= block.timestamp, \"Start must be in the future\");\n        require(_endTime > _startTime, \"End must be after start\");\n\n        votingStartTime = _startTime;\n        votingEndTime = _endTime;\n\n        emit VotingPeriodSet(_startTime, _endTime);\n    }\n\n    // Helpers de leitura\n    function candidatesCount() public view returns (uint) {\n        return candidateIds.length;\n    }\n}\n"
      }
    }
  }
}